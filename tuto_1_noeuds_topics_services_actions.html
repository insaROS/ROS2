<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tutoriels ROS2 </title>
    <link rel="short icon" href="pdf/INSA.ico" />
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <h1>Tutoriels ROS2</h1>
    </header>
    
    <button id="menu-button">Menu</button>
    <nav>
        <a href="/ROS2/index.html">Accueil</a>
        <a href="/ROS2/tuto_installation_ros2.html">Installation de ROS2</a>
        <a href="/ROS2/tuto_installation_prerequis_matlab.html">Installation des prérequis à l'utilisation de Matlab avec ROS2</a>
        <a href="/ROS2/tuto_1_noeuds_topics_services_actions.html" class="active">Noeuds, Topics, Services et Actions</a>
        <a href="/ROS2/tuto_2_packages_python_cpp.html">Création de packages Python et C++</a>
        <a href="/ROS2/tuto_3_ros_domain_id.html">Comprendre les ROS_DOMAIN_ID</a>
        <a href="/ROS2/tuto_4_ros2_matlab.html">Utiliser Matlab avec ROS2</a>
        <a href="/ROS2/tuto_5_micro-ros.html">Micro-ROS</a>
        <a href="/ROS2/tuto_6_turtlebot3.html">TurtleBot3</a>
        <a href="/ROS2/contact.html">Bibliographie</a>
        <!-- Ajoutez d'autres liens pour chaque tutoriel -->
    </nav>

    <div id="menu-dropdown">
        <a href="/ROS2/index.html">Accueil</a>
        <a href="/ROS2/tuto_installation_ros2.html">Installation de ROS2</a>
        <a href="/ROS2/tuto_installation_prerequis_matlab.html">Installation des prérequis à l'utilisation de Matlab avec ROS2</a>
        <a href="/ROS2/tuto_1_noeuds_topics_services_actions.html" class="active">Noeuds, Topics, Services et Actions</a>
        <a href="/ROS2/tuto_2_packages_python_cpp.html">Création de packages Python et C++</a>
        <a href="/ROS2/tuto_3_ros_domain_id.html">Comprendre les ROS_DOMAIN_ID</a>
        <a href="/ROS2/tuto_4_ros2_matlab.html">Utiliser Matlab avec ROS2</a>
        <a href="/ROS2/tuto_5_micro-ros.html">Micro-ROS</a>
        <a href="/ROS2/tuto_6_turtlebot3.html">TurtleBot3</a>
        <a href="/ROS2/contact.html">Bibliographie</a>
        <!-- Ajoutez d'autres liens pour chaque tutoriel -->
    </div>

    
    <main>
        
        
        <section>
            <article>
                <h2>Tutoriel : Noeuds, Topics, Services et Actions</h2>

                <div class="table-of-contents">
                    <h3>Table des matières</h3>
                    <ul>
                        <li><a href="#section1">Introduction</a></li>
                        <li><a href="#section2">Noeuds, Topics, Services et Actions</a></li>
                        <li><a href="#section3">Lancer TurtleSim et contrôler la tortue avec le teleopkey</a></li>
                        <li><a href="#section4">Visualisation des noeuds et topics avec rqt graph</a></li>
                        <li><a href="#section5">Comprendre les topics avec TurtleSim</a></li>
                        <li><a href="#section6">Comprendre les topics avec TurtleSim et rqt</a></li>
                        <li><a href="#section7">Comprendre les actions avec TurtleSim</a></li>
                        <li><a href="#section8">Comprendre les services avec TurtleSim</a></li>
                    </ul>
                </div>

                <section id="section1">
                    <h3>Introduction</h3>
                    <p>Ce premier tutoriel a pour but d'apprendre à se servir de RO2 et de ses commandes de base à l'aide de l'outil 
                        TurtleSim. Dans cette optique, nous allons dans un premier temps nous intéresser à ce que sont ROS2 et TurtleSim.
                    </p>

                    <ul>
                        <li>
                            <p><strong>ROS2</strong> : ROS est un middleware (un software qui se comporte comme une passerelle entre des applications et 
                                des bases de données ou des systèmes d'exploitation, aussi appelé intergiciel en français). ROS2 est une 
                                nouvelle version de ROS, comportant à peu près les mêmes composants, mais dont l'architecture change 
                                fondamentalement. ROS2, tout comme ROS, possède une architecture basée sur le principe de systèmes en 
                                temps réel distribués/répartis. Cela signifie que l'architecture est composée de nœuds qui se chargent 
                                d'effectuer des calculs ou des opérations simples, reliés entre eux par un réseau en temps réel.
                            </p>
                            <p>La différence entre les deux, vient du protocole réseau utilisé. ROS2 utilise un protocole réseau DDS (Data Distribution Service),
                                 qui a pour but de simplifier la programmation réseau. Chaque nœud créé avec ce protocole est à la fois un Publisher et un Subscriber 
                                , et est automatiquement créé sur une fraction du sous-réseau auquel ROS2 a accès. Cette fraction est appelée domaine, et tous les nœuds d'un domaine sont connectés entre 
                                 eux dès lors leur création. Cela rend à la fois la connexion à un réseau ROS2 plus facile, et plus sécuritaire, car la simple création 
                                 d'un nœud sur le réseau permet d'avoir accès à l'ensemble du réseau, mais il faut connaître à l'avance le sous-réseau ainsi que le 
                                 domaine sur lequel le réseau est situé.
                            </p>
                        </li>
                        <li>
                            <p><strong>TurtleSim</strong> : TurtleSim est un outil d'apprentissage créé pour ROS et ROS2 afin d'appréhender plus facilement leurs différents concepts. 
                                Cet outil se compose d'un espace sur lequel plusieurs tortues peuvent évoluer, et différents topics, services et actions sont accessibles afin de faire bouger ces 
                                tortues et récupérer les données disponibles. Bien que pouvant paraître simple, TurtleSim permet d'avoir un premier contact avec 
                                l'ensemble des concepts de ROS et ROS2, sans risque d'abimer un système réel.
                            </p>
                        </li>
                    </ul>
                </section>

                <section id="section2">
                    <h3>Nœuds, Topics, Services et Actions</h3>
                    <p>Vous trouverez quelques définitions pour mieux comprendre le fonctionnement de ROS2 (quasiment identique à ROS) :</p>

                    <ul>
                        <li>
                            <p><strong>Nœuds</strong> : Un nœud est l'unité fondamentale de ROS2, et dont la tâche consiste la plupart du temps à réaliser une action spécifique. 
                                Ils peuvent être crées de diverses manières, mais leur fonctionnement reste similaire. 
                                Il en existe deux catégories principales : les nœuds "Publisher" et les nœuds "Subscriber". De ces deux catégories est née une troisième catégorie : 
                                les nœuds "Composed", qui sont composées d'un "Publisher" et d'un "Subscriber". 
                                Le rôle d'un "Publisher" est de fournir des informations à au moins un "Subscriber", et celui-ci choisit quelles informations doivent lui être 
                                envoyées avant d'attendre de les recevoir. Un "Subscriber" peut avoir souscrit à plusieurs "Publisher", et un "Publisher" peut fournir la même 
                                information à plusieurs "Subscriber".
                            </p>
                            <p>Les trois points suivants sont des interfaces permettant aux nœuds de communiquer entre eux. Chacun de ces types d'interface diffère 
                            des autres sur certains points. De plus, ils ont chacun leur domaine d'application.
                            </p><br>
                            
                        </li>

                        

                        <li>
                            <p><strong>Topics</strong> : Les topics sont des canaux de communication unidirectionnels qui relient entre eux les différents nœuds. Ils agissent comme une 
                                sorte de relayeur d'informations. Ils reçoivent chacun les informations d'un seul noeud Publisher et peuvent les transmettre à plusieurs Subscriber. 
                                Ils permettent ainsi à plusieurs entités d'avoir accès à un même topic, mais l'information ne se transmets que dans un seul sens.
                                Un topic est donc dit "<strong>asynchrone</strong>". Le "Publisher" ne sait pas qui sont les "Subscriber" qui vont récupérer les informations 
                                transmises à ce topic. Les topics sont utilisées pour les flots de données continus, tel que des données de capteurs (position/vitesse/distance...).
                            </p><br>
                        </li>

                        <li>
                            <p><strong>Services</strong> : Les services sont des terminaux qui relient deux nœuds directement entre eux, et dont les informations peuvent être 
                                transmises dans les deux sens selon le système Request/Reply. Les services sont dit "<strong>synchrones</strong>". Ainsi, le nœud ayant effectué la demande,
                                 attends la réponse de la part du second nœud. Les services sont donc utilisés pour des procédures qui se terminent rapidement, comme des calculs rapides ou 
                                 la récupération de l'état d'un nœud. L'utilisation d'un service pour une procédure longue risque de bloquer les deux nœuds pour le temps de la procédure, et
                                  de générer des problèmes dans tous les autres nœuds qui pourraient être connectés à ceux-ci. Les services sont donc généralement utilisés pour récupérer 
                                  rapidement des données spécifiques.
                            </p><br>
                        </li>

                        <li>
                            <p><strong>Actions</strong> : Les actions ressemblent beaucoup à des services dans le sens où les actions utilisent également le système Request/Reply. 
                                La différence est qu'une action possède deux terminaux assimilés au nœuds : un client d'action (qui formule la requête) et un serveur d'action 
                                (qui réalise la tâche). Trois services et deux topics transitent entre ces deux nœuds :
                            </p>
                            <ul style="list-style-type: square;">
                                <li>
                                    <p><strong><i>Les services</i></strong> : <i>Send goal, Cancel goal, Get result</i>. Ils transitent du client d'action vers le serveur d'action.</p>
                                </li>
                                <li>
                                    <p><strong><i>Les topics</i></strong> : <i>Feedback</i> et <i>Status</i>. Ils transitent pour leur part dans le sens inverse aux services, 
                                        c'est-à-dire du serveur d'action vers le client d'action.
                                    </p>
                                </li>
                            </ul>

                            <p>L'action va donc consister en demandes d'objectifs par le nœud formulant la requête. Ces demandes seront transmises au serveur d'action. Celui-ci va alors 
                                envoyer de façon récurrente la progression de l'action ainsi que son statut au client d'action. Le client d'action peut alors choisir de demander l'annulation 
                                d'une action en cours ou bien de récupérer le statut final d'une action. Plusieurs actions peuvent être demandées à un même serveur d'action car chaque action 
                                possède son propre identifiant. Les actions servent donc à pallier le problème des services : ils seront utilisés pour des processus long mais nécessitant des 
                                retours sur sa progression de façon régulière. Elles sont donc principalement utilisées pour des actions réelles, tel que la mise en mouvement de robot.
                            </p><br>
                        </li>

                        <li>
                            <p><strong>Différence ROS et ROS2</strong> : Avec ROS, les nœuds établissent des communications entre eux en passant par un serveur (un ROS Master : terminal où 
                                on écrit la commande : $ roscore). Dans ROS2 il n'y a plus de ROS master. La méthode de communication des nœuds a été modifiée afin que ces communications puissent 
                                se créer directement de nœud à nœud sans passer par un serveur (utilisation de la méthode pear-to-pear directement). ROS2 est donc un système à part de ROS, qui 
                                utilise un protocole de réseau DDS (Data Distribution Service) qui permet une sécurité et une fiabilité qui n'étaient pas le point fort des protocole TCP/IP 
                                (Transmission Control Protocol/Internet Protocol) et UDP/IP (User Datagram Protocol) modifiés utilisé par ROS et couplés au ROS master.
                            </p>
                            <p>En effet, le protocole DDS est bien plus sécuritaire que les protocoles UDP/IP ou TCP/IP, et l'absence de ROS master fait que l'ensemble du système ne repose 
                                plus sur le fonctionnement d'un seul élément. Il est cependant possible de lier des nœuds ROS2 à des nœuds ROS grâce à un pont qui permettent de recréer un 
                                système existant déjà sur ROS plus facilement. Ce système est pour le moment particulièrement utile car certains packages n'existent pas encore pour ROS2. 
                                Il suffit donc de créer un nœud ROS accédant au package et de le lier à un nœud ROS2 pour régler ce problème.
                            </p>
                        </li>
                    </ul>
                </section>


                <section id="section3">
                    <h3>Lancer TurtleSim et contrôler la tortue avec le teleopkey</h3>

                    <section id="subsection3-1">
                        <h4>Mise de la source dans le terminal</h4>
                        <ol>
                            <li>
                                <p>Ouvrez un terminal avec "<strong><i>ctrl+alt+T</i></strong>"</p>
                            </li>
                            <li>
                                <p>Indiquez à ce terminal le chemin des fichiers de configuration de ROS2. Cela vous permettra de pouvoir utiliser des fonctions de ROS2. 
                                    Voici la commande à taper dans le terminal :
                                </p>
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code1')">Copier</button>
<pre id="code1" class="code-content">
source /opt/ros/humble/setup.bash
</pre>
                                </div>

                                <img src="images/tuto_1/section3/source_ROS2.png" width="350px">
                                <p>Après avoir tapé cette commande dans votre terminal, vous pourrez donc avoir accès à toutes les fonctions primaires de ROS2. Une autre méthode permet d'avoir 
                                    automatiquement tous les terminaux sourcés. Cette seconde méthode sera vu dans la section <a href="#subsection3-5">Mise de la source dans fichier ~/.bashrc</a>.
                                </p>
                            </li>

                        </ol>
                    </section>

                    <section id="subsection3-2">
                        <h4>Lancer TurtleSim</h4>
                        <ol>
                            <li>
                                <p>Pour lancer TurtleSim, nous devons activer le nœud de TurtleSim. Pour ce faire nous devons utiliser une structure de commande particulière. Voici la structure à utiliser :</p>
                                <div class="code-block" style="background-color: lightgrey;">
<pre class="code-content">
ros2 run &lt;package_name&gt; &lt;executable_name&gt;
</pre>
                                </div>
                                <p>Dans notre cas <code>&lt;package_name&gt;</code> sera l'application TurtleSim qui se nommera <code>turtlesim</code> et <code>&lt;executable_name&gt;</code> sera l'exécutable du nœud de TurtleSim qui sera <code>turtlesim_node</code>.</p>
                            </li>

                            <li>
                                <p>Voici la commande à taper dans le terminal :</p>
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code2')">Copier</button>
<pre id="code2" class="code-content">
ros2 run turtlesim turtlesim_node
</pre>
                                </div>
                                <img src="images/tuto_1/section3/ros2 run turtlesim.png" width="350px">
                            </li>

                            <li>
                                <p>Une fenêtre "TurtleSim" va s'ouvrir :</p>
                                <img src="images/tuto_1/section3/turtlesim.png" width="600px">
                            </li>

                            <li>
                                <p>Plusieurs informations apparaissent dans le terminal :</p>
                                <ul style="list-style-type: '- ';">
                                    <li><p>TurtleSim a été démarré avec le nœud <code>/turtlesim</code></p></li>
                                    <li><p>Une tortue a été créée avec le nom <code>turtle1</code></p></li>
                                    <li><p>Et elle a été placée dans la fenêtre TurtleSim avec les coordonnées x, y et &theta; suivantes : <br> <code>x=5.54</code>, <code>y=5.54</code> et une orientation <code> &theta;=0.00 rad</code></p></li>
                                </ul>
                            </li>
                        </ol>
                    </section>

                    <section id="subsection3-3">
                        <h4>Lancer la télécommande</h4>
                        <p>Dans cette partie, nous allons voir comment lancer une télécommande qui nous permettra de faire bouger la tortue, <code>turtle1</code> dans la fenêtre TurtleSim.</p>

                        <ol>
                            <li>
                                <p>Ouvrez un second terminal et tapez la commande pour ajouter la source à ce terminal.</p>
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code2.1')">Copier</button>
<pre id="code2.1" class="code-content">
source /opt/ros/humble/setup.bash
</pre>
                                </div>
                            </li>
                            <li>
                                <p>Pour lancer la télécommande, nous devons lancer le nœud de la télécommande. Voici la structure :</p>
                                <div class="code-block" style="background-color: lightgrey;">
<pre class="code-content">
ros2 run &lt;package_name&gt; &lt;executable_name&gt;
</pre>
                                </div>

                                <p>Dans ce cas <code>&lt;package_name&gt;</code> est TurtleSim qui se nommera <code>turtlesim</code> et <code>&lt;executable_name&gt;</code> est l'exécutable du nœud de la télécommande qui sera <code>turtle_teleop_key</code>.</p>
                            </li>

                            <li>
                                <p>Voici, finalement, la commande à taper dans le 2nd terminal :</p>
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code3')">Copier</button>
<pre id="code3" class="code-content">
ros2 run turtlesim turtle_teleop_key
</pre>
                                </div>
                                <img src="images/tuto_1/section3/ros2 run turtlesim teleop.png" width="380px">
                                <p>Cela va démarrer la télécommande qui vous permettra de contrôler les mouvements de la tortue dans l'environnement TurtleSim en utilisant les touches du clavier.</p>
                            </li>

                            <li>
                                <p>Vous allez donc pouvoir contrôler la tortue avec les 4 flèches de votre clavier :</p>
                                <img src="images/tuto_1/section3/turtlesim et teleop.png" width="600px">
                                <p><i>Nous verrons dans un des prochains tutoriels à quoi correspondent les rotations vers les orientations absolue avec les  touches G,B,V,C,D,E,R et T.</i></p>
                            </li>
                        </ol>
                    </section>

                    <section id="subsection3-4">
                        <h4>Lancer TurtleSim et la télécommande dans le même terminal</h4>
                        <ol>
                            <li>
                                <p>Arrêtez la commande de de la télécommande TurtleSim dans le second terminal et aussi la commande de TurtleSim dans le premier terminal, en faisant un "<code>ctrl+C</code>" dans chaque terminal.</p>
                            </li>
                            <li>
                                <p>Fermez un des deux terminaux.</p>
                            </li>
                            <li id="turtlesim_arr_p">
                                <p>Sur le terminal qui vous reste, tapez la commande pour lancer le nœud de TurtleSim avec un "<code>&</code>" à la fin . Le "<code>&</code>" a pour but de faire fonctionner TurtleSim en arrière-plan dans ce terminal.</p>
                                <p id="cmd_turtlesim_arr_plan">Voici la commande :</p>
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code4')">Copier</button>
<pre id="code4" class="code-content">
ros2 run turtlesim turtlesim_node &
</pre>
                                </div>
                                <img src="images/tuto_1/section3/ros2 run turtlesim arriere plan.png" width="380px">
                                <p>Faites "<code>Entrer</code>" et vous constaterez que vous pouvez de nouveau utiliser ce terminal.</p>
                            </li>

                            <li id="télécommande">
                                <p>Tapez la commande pour avoir la télécommande <code>teleop_key</code> :</p>
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code5')">Copier</button>
<pre id="code5" class="code-content">
ros2 run turtlesim turtle_teleop_key
</pre>
                                </div>
                                <img src="images/tuto_1/section3/turtlesim et teleop 1 terminal.png" width="600px">

                            </li>

                            <li>
                                <p>Arrêtez la télécommande en faisant "<code>ctrl+C</code>".</p>
                            </li>
                            <li>
                                <p>Arrêtez maintenant la commande qui à lancé TurtleSim en arrière plan. Pour retrouver la commande mise en arrière plan tapez la commande "<code>fg</code>" ("<code>fg</code>" signifie foreground) puis faites "<code>ctrl+C</code>".</p>
                            </li>

                            <p>Vous avez réussi à faire bouger votre tortue dans TurtleSim à l'aide de la télécommande en ayant lancé le noeuds de TurtleSim en arrière plan. 
                                La prochaine étape concerne la mise automatique de la source de RO2 pour chaque nouveau terminal ouvert.
                            </p>

                        </ol>
                        
                    </section>

                    <section id="subsection3-5">
                        <h4>Mise de la source dans fichier ~/.bashrc</h4>
                        <p>Cette partie consiste à ce que la source de ROS2 soit ajouté automatiquement pour chaque nouveau terminal que vous ouvrez. 
                            Pour ce faire suivez les instructions suivantes :
                        </p>

                        <ol>
                            <li>
                                <p>
                                    Ouvrez un terminal avec "<code>ctrl+alt+T</code>", puis modifier le fichier <code>.bashrc</code> avec la commande suivante puis tapez votre mot de passe 
                                    (<i>lorsque vous rentrez votre mot de passe celui-ci ne s'affiche pas</i>):
                                </p>
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code6')">Copier</button>
<pre id="code6" class="code-content">
sudo nano .bashrc
</pre>
                                </div>
                                <img src="images/tuto_1/section3/sudo_nano_bashrc.png" width="250px">
                                <p>
                                    Explication de la commande :
                                </p>
                                <ul style="list-style-type: '';">
                                    <li><p><strong>sudo</strong> : nous l'utilisons pour lancer une commande dans un terminal en mode administrateur (pas obligatoire).</p></li>
                                    <li><p><strong>nano</strong> : c'est un éditeur de fichier et permet de les modifier.</p> </li>
                                    <li><p><strong>.bashrc</strong> : c'est un fichier de configuration de notre machine virtuelle.</p></li>
                                </ul>
                                <p>Donc la commande <code>sudo nano .bashrc</code> permet d'ouvrir le fichier <code>.bashrc</code> dans l'éditeur de fichier <code>nano</code> le tout en mode administrateur.</p>
                            </li>

                            <li>
                                <p>
                                    Pour pouvoir sourcer automatiquement l'environnement ROS2 dans vos nouveaux terminaux, vous devez indiquer dans ce fichier le chemin du fichier setup de ROS2.  
                                    Voici la ligne de code que vous avez à mettre à la fin de ce fichier : 
                                </p>
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code7')">Copier</button>
<pre id="code7" class="code-content">
source /opt/ros/humble/setup.bash
</pre>
                                </div>
                            </li>
                            <li>
                                <p>Ajoutez le chemin du fichier setup de ROS2 à la fin de ce fichier et vous devriez obtenir :</p>
                                <img src="images/tuto_1/section3/bashrc.png" width="450px">
                            </li>

                            <li>
                                <p>Sauvegardez et quittez le fichier avec "<code>ctrl+O</code>", "<code>Entrer</code>" et ensuite "<code>crtl+X</code>".</p>
                                <p>L'ajout de cette ligne de code permet au système de connaître automatiquement le chemin du fichier setup de ROS2. 
                                    C'est-à-dire, que pour chaque nouveau Terminal que vous ouvrez, le fichier setup sera sourcé.
                                </p>
                            </li>

                            <li>
                                <p>Fermez ce terminal soit en cliquant sur la croix en haut à droite soit en écrivant la commande "<code>exit</code>" dans le terminal.</p>
                            </li>

                            <p> Le 1er tutoriel est fini. Passons au suivant pour contrôler la tortue en publiant des messages directement sur le topic <code>turtle1/cmd_vel</code>.</p>
                        </ol>
                    </section>

                </section>


                <section id="section4">
                    <h3>Visualisation des nœuds et topics avec rqt graph</h3>

                    <section id="subsection4-1">
                        <h4>Ouvrir rqt_graph</h4>
                        <ol>
                            <li>
                                <p>Ouvrez un terminal avec "<code>ctrl+alt+T</code>"</p>
                            </li>

                            <li id="rqt_graph">
                                <p>Lancez <code>rqt_graph</code> en tapant la commande suivante et une fenêtre <code>rqt_graph</code> va s'ouvrir :</p>
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code8')">Copier</button>
<pre id="code8" class="code-content">
rqt_graph
</pre>
                                </div>
                                <img src="images/tuto_1/section4/cmd_rqt_graph.png" width="175px">
                                <br>
                                <img src="images/tuto_1/section4/rqt_graph_vide.png" width="450px">
                                <ul style="list-style-type: '- ';">
                                    <li><p>Dans la fenêtre <code>rqt_graph</code>, cliquez sur <code>Nodes only</code> (A côté des deux flèches bleues)</p></li>
                                    <li><p>Choisissez ensuite <code>Nodes/Topics (all)</code>.</p></li>
                                    <li><p>Décocher ensuite <code>Dead sinks</code> et <code>Leaf topics</code> de la partie <code>Hide</code>.</p></li>
                                </ul>
                                <p><code>rqt_graph</code> permet de voir l'interaction entre les différents nœuds et topics actifs en ce moment. Notre <code>rqt_graph</code> est vide. <br><i>Est-ce normal ?</i>
                                    Oui, nous avons pour le moment aucun nœud actif dans les terminaux. De ce fait nous voyons rien sur ce graph</p>
                            </li>
                        </ol>

                    </section>

                    <section id="subsection4-1">
                        <h4>Lancer TurtleSim</h4>

                        <ol>
                            <li><p>Ouvrez un second Terminal.</p></li>
                            <li>
                                <p>Tapez la commande qui permet de lancer TurtleSim en arrière plan :</p>
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code9')">Copier</button>
<pre id="code9" class="code-content">
ros2 run turtlesim turtlesim_node &
</pre>
                                </div>
                                <img src="images/tuto_1/section3/ros2 run turtlesim arriere plan.png" width="380px">
                                    
                            </li>

                            <li>
                                <p>Appuyez ensuite sur le bouton "Rafraîchir" de la fenêtre <code>rqt_graph</code> (bouton avec 2 flèches bleues sur la gauche).</p>
                                <p>Vous obtiendrez ceci :</p>
                                <img src="images/tuto_1/section4/rqt_graph_turtle1.png" width="500px">
                            </li>
                            
                            <p>Vous pouvez donc voir le nœud turtlesim que vous venez de lancer avec la commande ci-dessus. 
                                Vous pouvez voir aussi tous les topics, liés à la tortue <code>/turtle1</code>, qui peuvent interagir avec le nœud. 
                                Vous retrouverez le topic <code>/turtle1/cmd_vel</code> qui sera utilisé dans la suite de ce tutoriel.</p>
                            
                        </ol>

                    </section>

                    <section id="subsection4-1">
                        <h4>Lancer la télécommande</h4>

                        <ol>
                            <li>
                                <p>Tapez la commande suivante, dans le second terminal, pour lancer la télécommande :</p>
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code10')">Copier</button>
<pre id="code10" class="code-content">
ros2 run turtlesim turtle_teleop_key
</pre>
                                </div>
                                <img src="images/tuto_1/section3/ros2 run turtlesim teleop.png" width="380px">
                            </li>

                            <li>
                                <p> Retournez sur la fenêtre <code>rqt_graph</code> et rafraîchissez le graph. Vous allez obtenir ceci :</p>
                                <img src="images/tuto_1/section4/rqt_graph_turtle1_teleop.png" width="500px">
                                
                            </li>
                            <p>Vous pouvez donc voir que le nœud de la télécommande est apparu lui aussi sous le nom <code>/teleop_turtle</code>. On peut voir que la télécommande ne peut agir que sur le topic <code>/turtle1/cmd_vel</code>.</p>
                        </ol>
                    </section>
                
                </section>


                <section id="section5">
                    <h3>Comprendre les topics avec TurtleSim</h3>

                    <section id="subsection5-1">
                        <h4>Trouver la liste des "topics" actifs</h4>
                        
                        <ol start="0">
                            <li><p>Fermez tous les terminaux ouverts.</p></li>
                            <li><p>Lancez TurtleSim dans un nouveau terminal.</p></li>
                            <li>
                                <p>Dans un second terminal, visualisez les topics actifs en tapant la commande :</p>
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code11')">Copier</button>
<pre id="code11" class="code-content">
ros2 topic list
</pre>
                                </div>
                                <img src="images/tuto_1/section5/ros2_topic_list.png" width="230px">

                            </li>
                            <p>Vous constaterez que vous avez dans la liste des topics actifs, les topics sur lesquels TurtleSim publie ses données. Nous avons déjà vu ces topics dans la section précédente.
                                Le topic qui nous intéresse est le topic <code>/turtle1/cmd_vel</code>.
                            </p>
                        </ol>
                    </section>

                    <section id="subsection5-2">
                        <h4>Trouver les informations précises d'un "topic"</h4>
                        <ol>
                            <li>
                                <p>Tapez la commande suivante dans le second terminal :</p>
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code12')">Copier</button>
<pre id="code12" class="code-content">
ros2 topic info /turtle1/cmd_vel
</pre>
                                </div>
                                <img src="images/tuto_1/section5/ros2_topic_info_cmd_vel.png" width="350px">
                            </li>
                            <li>
                                <p>Le topic <code>/turtle1/cmd_vel</code> accepte uniquement les messages de type <code>geometry_msgs/msg/Twist</code>.</p>
                            </li>
                            <p>On peut remarquer que nous avons la présence des termes "Publisher" et "Subscriber". Le Publisher est un noeud qui publie des données sur un topic et un Subscriber quant à lui est un noeud qui s'abonne à un topic pour recevoir les données que ce topic reçoit. Dans notre cas la télécommande de TurtleSim est un noeud "Publisher" du topic <code>/turtle1/cmd_vel</code> et TurtleSim est un noeud "Subscriber" de ce topic.</p>
                        </ol>
                    </section>

                    <section id="subsection5-3">
                        <h4>Trouver les caractéristiques d'un "geometry_msgs/msg/Twist"</h4>
                        <ol>
                            <li>
                                <p>Tapez la commande suivante, pour trouver les caractéristique d'un message de type <code>geometry_msgs/msg/Twist</code> :</p>
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code13')">Copier</button>
<pre id="code13" class="code-content">
ros2 interface show geometry_msgs/msg/Twist
</pre>
                                </div>
                                <img src="images/tuto_1/section5/carac_geo_msg_twist.png" width="550px">
                            </li>

                            <li>
                                <p>Vous pouvez voir qu'un message de type <code>geometry_msgs/msg/Twist</code> contient deux vecteurs de dimension 3. Le premier pour indiquer les vitesses linéaires 
                                    que l'on veut donner à la tortue et le second pour les vitesses angulaires.
                                </p>
                                <p>La tortue évoluant dans un système 2D, il sera uniquement possible de lui envoyer des vitesses linéaires selon x et y et une 
                                    vitesse angulaire selon z. L'axe x est correspond à la direction de la tortue, l'axe y à la vitesse latérale de la tortue 
                                    et l'axe z correspond la vitesse angulaire de la tortue en sachant que cet axe pointe vers vous.
                                </p>
                            </li>
                        </ol>
                    </section>

                    <section id="subsection5-4">
                        <h4>Envoyer un geometry_msgs/msg/Twist sur le topic /turtle1/cmd_vel</h4>
                        <ol>
                            <li>
                                <p>Observez la structure de la commande permettant d'envoyer un message sur un topic :</p>
                                <div class="code-block" style="background-color: lightgrey;">
<pre class="code-content">
ros2 topic pub &lt;pub_frequency&gt; &lt;topic_name&gt; &lt;message_type&gt; &lt;message&gt;
</pre>
                                </div>
                            </li>

                            <li id="envoie_msg_twist_topic">
                                <p>Tapez la commande suivante, pour envoyer un <code>geometry_msgs/msg/Twist</code> sur le topic <code>/turtle1/cmd_vel</code> 
                                    (<i>en spécifiant en paramètre "<code>--once</code>" pour n'envoyer qu'un seul message sur ce topic</i>)  :
                                </p>
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code14')">Copier</button>
<pre id="code14" class="code-content">
ros2 topic pub --once /turtle1/cmd_vel geometry_msgs/msg/Twist "{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}"
</pre>
                                </div>
                                <img src="images/tuto_1/section5/cmd_pub_geo_once.png" width="600px">
                                <p>Vous pourrez voir dans le terminal que le <code>geometry_msgs/msg/Twist</code> a été publié <code>/turtle1/cmd_vel</code> :</p>
                                <img src="images/tuto_1/section5/pub_geo_msg_twist_once.png" width="600px">
                            </li>

                            <li>
                                <p>On remarque que notre tortue <code>turtle1</code> a avancée en tournant sur la gauche.</p>
                                <img src="images/tuto_1/section5/turtlesim_pub_once.png" width="250px">
                                <p>Ce qui correspond bien à une vitesse linéaire selon x et une vitesse angulaire selon z.</p>
                            </li>
                        </ol>
                    </section>

                    <section id="subsection5-5">
                        <h4>Envoyer un message en boucle sur le topic /turtle1/cmd_vel</h4>
                        <ol>
                            <li>
                                <p>Pour envoyer en boucle le message précédent, il vous suffit de modifier le paramètre "<code>--once</code>" 
                                    par "<code>--rate &lt;freq_Hz&gt;</code>" (<i><code>&lt;freq_Hz&gt;</code> correspond à la fréquence d'envoi du message</i>). 
                                    Dans notre cas, nous allons écrire le paramètre "<code>--rate 1</code>" pour envoyer ce message 
                                    successivement à une fréquence de 1Hz.
                                </p>
                                <p>Tapez la commande suivante :</p>
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code15')">Copier</button>
<pre id="code15" class="code-content">
ros2 topic pub --rate 1 /turtle1/cmd_vel geometry_msgs/msg/Twist "{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}"
</pre>
                                </div>
                                <img src="images/tuto_1/section5/pub_geo_msg_twist_rate.png" width="600px">
                                    
                            </li>

                            <li>
                                <p>On remarque donc que le message est bien envoyé en boucle avec une fréquence de 1Hz et que la tortue tourne en rond :</p>
                                <img src="images/tuto_1/section5/turtlesim_pub_rate.png" width="600px">
                                <p> Vous pourrez voir les messages qui ont été publiés sur le topic <code>/turtle1/cmd_vel</code>, 
                                    s'afficher toutes les secondes (<i>car on à mis un rate de 1Hz</i>)
                                </p>
                            </li>

                            <li>
                                <p>Arrêtez l'envoi de ce message périodique en faisant simplement "<code>crtl+C</code>".</p>
                            </li>
                            <li>
                                <p>Fermez l'ensemble des terminaux pour passer au tutoriel suivant !</p>
                            </li>
                            <p>La partie du tutoriel sur les topics est finie. Dans la partie suivante nous étudirons le fonctionnement des topics en utilisant TurtleSim et rqt.</p>
                        </ol>
                    </section>

                </section>


                <section id="section6">
                    <h3>Comprendre les topics avec TurtleSim et rqt</h3>

                    <section id="subsection6-1">
                        <h4>Ouvrir rqt</h4>
                        <ol>
                            <li><p>Ouvrez un nouveau terminal et vérifiez la source de ROS2</p></li>
                            <li>
                                <p>Tapez la commande suivante pour ouvrir <code>rqt</code> :</p>
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code16')">Copier</button>
<pre id="code16" class="code-content">
rqt
</pre>
                                </div>
                                <img src="images/tuto_1/section6/cmd_rqt.png" width="150px">
                                <p>Une fenêtre <code>rqt</code> va s'ouvrir :</p>
                                <img src="images/tuto_1/section6/rqt_vide.png" width="400px">
                                <p>Si vous arrivez sur <code>rqt</code> mais pour autre chose que <code>&gt;Message Publisher</code>. 
                                    Allez dans Plugins, puis Topics et cliquez sur Message Publisher.
                                </p>
                                <p><strong>Définition</strong> : <code>rqt</code> est un outil de ROS et ROS2 permettant de visualiser, interagir et 
                                    modifier la structure des nœuds, des topics et des services du système, en offrant une interface 
                                    graphique pour le développement et le débogage de robots.
                                </p>
                                <p>Dans notre cas, nous allons utiliser <code>rqt</code> pour envoyer des messages sur le topic <code>cmd_vel</code> d'une tortue dans TurtleSim.</p>
                            </li>

                            <li>
                                <p>Cliquez sur le menus déroulant des différents topics actifs. Vous verrez que les topics liés à la tortue de TurtleSim ne sont pas présents.</p>
                                <p>C'est normal, vous n'avez pas encore lancé TurtleSim.</p>
                            </li>
                        </ol>
                    </section>

                    <section id="subsection6-2">
                        <h4>Lancer TurtleSim</h4>
                        <ol>
                            <li>
                                <p>Ouvrez un nouveau terminal et lancez TurtleSim.</p>
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code16.1')">Copier</button>
<pre id="code16.1" class="code-content">
ros2 run turtlesim turtlesim_node
</pre>
                                </div>
                            </li>
                            <li>
                                <p>Cliquez sur les flèches bleues pour rafraîchir rqt et ensuite cliquez sur le menus déroulant des différents topics actifs. 
                                    Les topics liés à TurtleSim sont apparu et sélectionnez le topic <code>/turtle1/cmd_vel</code> :
                                </p>
                                <img src="images/tuto_1/section6/rqt_choix_topic.png" width="250px">
                            </li>

                            <li>
                                <p>On remarque que <code>rqt</code> trouve directement le type de message à utiliser sur ce topic :</p>
                                <img src="images/tuto_1/section6/rqt_choix_msg_auto.png" width="550px">
                            </li>
                        </ol>
                    </section>

                    <section id="subsection6-3">
                        <h4>Envoyer un geometry_msgs/msg/Twist sur le topic /turtle1/cmd_vel avec rqt</h4>
                        <ol>
                            <li>
                                <p>Cliquez sur le "<code>+</code>" bleu pour créer un <code>geometry_msgs/msg/Twist</code> :</p>
                                <img src="images/tuto_1/section6/creation_msg.png" width="550px">
                            </li>

                            <li>
                                <p>Cliquez sur la petite flèche sur la gauche du message pour développer le message :</p>
                                <img src="images/tuto_1/section6/msg_rqt_deroulé.png" width="350px">
                            </li>

                            <li>
                                <p> Paramétrez le message que vous allez envoyer. Choisissez les mêmes valeurs que pour la section <a href="#envoie_msg_twist_topic">Envoyer un message en boucle sur le topic /turtle1/cmd_vel 2.</a> 
                                    , soit une vitesse linéaire <code>x : 2.0, y : 0.0 , z : 0.0</code>  et une vitesse angulaire <code>x : 0.0, y : 0.0 , z : 1.8</code> : 
                                </p>
                                <img src="images/tuto_1/section6/msg_rqt_deroulé_modif.png" width="350px">
                                <p>La valeur du paramètre "<code>rate</code>" est effective uniquement lorsque la case en haut à gauche du message est coché. Dans notre cas, 
                                    nous voulons l'envoyer qu'une seule fois, donc laissez cette case décochée.
                                </p>
                            </li>

                            <li>
                                <p>Faites un clic droite sur le message à envoyer, puis cliquez sur <code>Publish Selected Once</code> (permet d'envoyer qu'un seul message)</p>
                                <img src="images/tuto_1/section6/published_selected_once.png" width="450px">
                                <p>Vous pouvez alors voir votre tortue bouger dans la fenêtre TurtleSim :</p>
                                <img src="images/tuto_1/section6/turtlesim_move.png" width="250px">
                            </li>

                            <li>
                                <p>Amusez-vous en changeant les paramètres du message et puis en l'envoyant. </p>
                                <p>Cependant certains messages ne sont pas valides. Vous ne pouvez utiliser que les vitesses linéaires x et y  (resp. déplacement avant/arrière et déplacement latéral droite/gauche) 
                                    et une vitesse angulaire selon z (l'axe z pointant vers vous) car ces 3 paramètres permettent de déterminer la position et l'orientation de la tortue dans ce système 2D :
                                </p>
                                <img src="images/tuto_1/section6/turtlesim_move_2.png" width="250px">
                            </li>
                        </ol>
                    </section>

                    <section id="subsection6-4">
                        <h4>Envoyer un geometry_msgs/msg/Twist en boucle avec rqt</h4>
                        <ol>
                            <li>
                                <p>Utilisez la fonctionnalité <code>rate</code> qui permet d'envoyer en boucle le même message. Modifiez les paramètres de votre message et aussi la valeur de <code>rate</code>. 
                                    La valeur de rate correspond à la fréquence d'envoi du message.
                                </p>
                            </li>

                            <li>
                                <p>Cochez la case à gauche du message pour que le paramètre <code>rate</code> soit pris en compte :</p>
                                <img src="images/tuto_1/section6/msg_rqt_deroulé_coché.png" width="350px">
                                <p>Vous verrez votre tortue bouger en boucle en fonction de votre message dès que vous aurez coché cette case. Décochez la case pour arrêter l'envoi cyclique de message.</p>
                            </li>
                        </ol>
                        <p>Vous comprenez donc maintenant le fonctionnement et les relations entre les "nœuds" et "topics". Dans le prochain tutoriel vous allez utiliser et comprendre le fonctionnement des "actions" avec TurtleSim.</p>

                    </section>

                </section>


                <section id="section7">
                    <h3>Comprendre les actions avec TurtleSim</h3>

                    <section id="subsection7-1">
                        <h4>Découvrir les actions</h4>
                        
                        <ol>
                            <li><p>Faites "<code>crtl+C</code>" dans tous les terminaux pour arrêter tous les processus en cours et fermez tous les terminaux ouverts.</p></li>
                            <li><p>Ouvrez un terminal et lancez TurtleSim en arrière plan (Voir la section <a href="#turtlesim_arr_p">Lancer TurtleSim et la télécommande dans le même terminal 3.</a>).</p></li>
                            <li>
                                <p>Lancez, ensuite, la télécommande dans le même terminal (Voir la section <a href="#télécommande">Lancer TurtleSim et la télécommande dans le même terminal 4.</a>).</p>
                                <p>Vous pourez voir ce message dans la télécommande :</p>
                                <img src="images/tuto_1/section7/0 teleop_touches_absolute.png" width="500px">
                                <p>La deuxième ligne correspond aux actions que l'on peut demander à la tortue de TurtleSim. (La première ligne correspond à l'utilisation des flèches pour piloter la tortue avec le topic <code>/turtle1/cmd_vel</code>, abordé précédemment dans les tutoriels).</p>
                                <p>On remarque que les touches <code>G|B|V|C|D|E|R|T</code> forment un "carré" autour de la touche '<code>F</code>' sur votre clavier. La position de chaque touche autour de '<code>F</code>' correspond à cette orientation dans la fenêtre TurtleSim. Par exemple, le '<code>E</code>' fera pivoter l'orientation de la tortue vers le coin supérieur gauche.</p>
                                <p>Prêtez attention au terminal où le nœud <code>/turtlesim</code> est exécuté. Chaque fois que vous appuierez sur l'une de ces touches, vous enverrez un objectif à un serveur d'action qui fait partie du nœud <code>/turtlesim</code>. L'objectif est de faire tourner la tortue dans une direction précise.</p>
                            </li>

                            <li>
                                <p>Appuyez sur la touche '<code>E</code>'. Un message relayant le résultat de l'objectif devrait s'afficher une fois que la tortue a terminée sa rotation : </p>
                                <img src="images/tuto_1/section7/1 result_goal.png" width="500px">
                                <p>Votre tortue à tournée vers le coin supérieur gauche :</p>
                                <div> 
                                    <img src="images/tuto_1/section7/2 turtle spawn.png" width="220px" style="display: inline-block; margin-right: 30px;">
                                    <img src="images/tuto_1/section7/2 fleche.png" width="125px" style="display: inline-block;">
                                    <img src="images/tuto_1/section7/3 turtle after result.png" width="220px" style="display: inline-block; margin-left: 30px;">
                                </div>
                                <p>La touche '<code>F</code>', au centre du carré de touche, permet d'annuler l'objectif en cours.</p>
                            </li>

                            <li>
                                <p>Appuyer, par exemple sur la touche '<code>C</code>',  pour faire tourner la tortue vers une coin inférieur gauche, puis sur la touche '<code>F</code>' avant que la tortue ne termine sa rotation.
                                    Dans le terminal où le nœud <code>/turtlesim</code> est exécuté, vous verrez le message suivant :
                                </p>
                                <img src="images/tuto_1/section7/4 cancel_goal.png" width="450px">
                                <p>Non seulement le côté client (votre entrée dans le teleop_key ) peut arrêter un objectif, mais le côté serveur (le noeud <code>/turtlesim</code>) le peut également. 
                                    Lorsque le serveur décide d'arrêter le traitement d'un objectif, on dit qu'il "abandonne" l'objectif.
                                </p>
                            </li>

                            <li>
                                <p>Essayez d'appuyer sur la touche '<code>T</code>', puis sur la touche '<code>G</code>' avant que la première rotation ne soit terminée. Dans le terminal où le nœud <code>/turtlesim</code> est exécuté, vous verrez le message suivant :</p>
                                <img src="images/tuto_1/section7/5 rotation goal received before a previous goal.png" width="500px">
                                <p>On remarque, sur la fenêtre TurtleSim, que la rotation vers '<code>T</code>' (coin supérieur droit) a été annulée et a été remplacée par une rotation vers l'orientation de '<code>G</code>' (droite).</p>
                            </li>
                        </ol>
                    </section>

                    <section id="subsection7-2">
                        <h4>Trouver la liste des "Action Servers" et "Action Clients" d'un noeud</h4>
                        <ol>
                            <li><p>Ouvrez un second terminal</p></li>
                            <li>
                                <p>Tapez la commande suivante :</p>
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code17')">Copier</button>
<pre id="code17" class="code-content">
ros2 node info /turtlesim
</pre>
                                </div>
                                <img src="images/tuto_1/section7/6 ros2 node info.png" width="280px">
                                <p>Cette commande renvoie une liste des "Subscribers", des "Publishers", des "Services", des "serveurs d'actions" et des "clients d'actions" de <code>/turtlesim</code> :</p>
                                <img src="images/tuto_1/section7/7 ros2 node info results.png" width="550px">
                                <p>On remarque que le nœud <code>/turtlesim</code> est un serveur de l'action <code>/turtle1/rotate_absolute</code>. C'est-à-dire qu'il peut recevoir des actions à effectuer et qu'il renvoie aussi des données au client.</p>
                            </li>

                            <li>
                                <p>Utilisez et modifiez la commande précédente pour trouver les informations du noeud <code>/teleop_turtle</code> :</p>
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code17.1')">Copier</button>
<pre id="code17.1" class="code-content">
ros2 node info /teleop_turtle
</pre>
                                </div>
                                <img src="images/tuto_1/section7/8 ros2 node info teleop.png" width="550px">
                                <p>On remarque que le nœud <code>/teleop_turtle</code> est un client de l'action <code>/turtle1/rotate_absolute</code>. C'est-à-dire qu'il peut envoyer actions que le serveur doit effectuer et il peut recevoir des données de la part du serveur.</p>
                            </li>
                        </ol>
                    </section>

                    <section id="subsection7-3">
                        <h4>Trouver la liste des actions disponibles et leurs informations</h4>
                        <ol>
                            <li>
                                <p>Tapez la commande suivante dans le second terminal pour avoir la liste des actions disponibles :</p>
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code18')">Copier</button>
<pre id="code18" class="code-content">
ros2 action list
</pre>
                                </div>
                                <img src="images/tuto_1/section7/9 actions list.png" width="220px">
                                <p>Vous obtiendrez dans le terminal la liste des actions disponible :</p>
                                <img src="images/tuto_1/section7/10 actions list result.png" width="220px">
                                <p>Cependant, chaque action possède un type précis. Il est possible de l'afficher en ajoutant le paramètre "<code>-t</code>" dans la commande précédente.</p>
                            </li>

                            <li>
                                <p>Tapez la commande suivante pour obtenir la liste des actions ainsi que leur type directement:</p>
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code19')">Copier</button>
<pre id="code19" class="code-content">
ros2 action list -t
</pre>
                                </div>
                                <img src="images/tuto_1/section7/11 actions list result type.png" width="400px">
                                <p>Entre crochets à droite de chaque nom d'action (dans notre cas, uniquement pour l'action <code>/turtle1/rotate_absolute</code>) se trouve le type d'action, 
                                    <code>turtlesim/action/RotateAbsolute</code>. Vous en aurez besoin lorsque vous voudrez exécuter une action à partir de la ligne de commande ou du code.
                                </p>
                            </li>

                            <li>
                                <p>Tapez la commande suivante dans le second terminal pour pouvoir analyser l'action <code>/turtle1/rotate_absolute</code> : </p>
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code20')">Copier</button>
<pre id="code20" class="code-content">
ros2 action info /turtle1/rotate_absolute
</pre>
                                </div>
                                <img src="images/tuto_1/section7/12 action info.png" width="380px">
                                <p>Vous obtiendrez dans le terminal les informations de cette action :</p>
                                <img src="images/tuto_1/section7/13 action info res.png" width="380px">
                                <p>Cela nous indique ce que nous avons appris plus tôt en exécutant ros2 node info sur chaque nœud : Le noeud <code>/teleop_turtle</code> est un client d'action et le noeud <code>/turtlesim</code> est un serveur d'action pour l'action <code>/turtle1/rotate_absolute</code></p>
                            </li>
                        </ol>
                    </section>

                    <section id="subsection7-4">
                        <h4>Visualisation de l'action /turtle1/rotate_absolute avec rqt_graph</h4>
                        
                        <ol>
                            <li><p>Tapez la commande pour ouvrir <code>rqt_graph</code>, toujours dans le second terminal (Voir la section <a href="#rqt_graph">Visualisation des nœuds et topics avec rqt graph 1.</a>).</p></li>
                            <li><p>Faites les réglages, concernant les cases à cocher ou à décocher dans <code>rqt_graph</code> (Voir la section <a href="#rqt_graph">Visualisation des nœuds et topics avec rqt graph 1.</a>).</p></li>
                            <li>
                                <p>Comme TurtleSim et la télécommande teleop_key sont lancés, les nœuds <code>/turtlesim</code> et <code>/teleop_turtle</code> le sont aussi. Vous obtiendrez :</p>
                                <img src="images/tuto_1/section7/14 rqt_graph.png" width="450px">
                                <p>Vous pouvez constater que l'action <code>/turtle1/rotate_absolute</code> peut recevoir des données du nœud <code>/turtlesim</code> (serveur de l'action) et que le nœud <code>/teleop_turtle</code> peut recevoir des données de cette action (client de l'action).</p>
                            </li>
                        </ol>
                    </section>

                    <section id="subsection7-5">
                        <h4>Trouver la structure du type d'action "turtlesim/action/RotateAbsolute"</h4>
                        <p>Une autre information dont vous aurez besoin avant d'envoyer ou d'exécuter vous-même un objectif d'action est la structure du type de cette action.
                            Rappelez-vous que vous avez identifié précédemment le type de <code>/turtle1/rotate_absolue</code> en exécutant la commande <code>$ ros2 action list -t</code> (type : <code>turtlesim/action/RotateAbsolute</code>).
                        </p>

                        <ol>
                            <li>
                                <p>Entrez la commande suivante pour déterminer la structure de ce type d'action :</p>
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code20.1')">Copier</button>
<pre id="code20.1" class="code-content">
ros2 interface show turtlesim/action/RotateAbsolute
</pre>
                              </div>
                                <img src="images/tuto_1/section7/15 interface show.png" width="450px">
                                <p>Vous obtiendrez dans le terminal :</p>
                                <img src="images/tuto_1/section7/16 interface show res.png" width="450px">
                            </li>

                            <li>
                                <p>Identifiez les différents paramètres : </p>
                                <ul style="list-style-type: '- ';">
                                    <li><p>La section du message au-dessus du premier "---" est la structure (type de données et nom) de la demande d'objectif.</p></li>
                                    <li><p>La section suivante est la structure du résultat.</p></li>
                                    <li><p>La dernière section est la structure du feedback.</p></li>
                                </ul>
                                <p>On remarque que ces trois paramètres sont du type float32 (soit des chiffres à virgule codés sur 32 bits).</p>
                            </li>
                        </ol>
                    </section>

                    <section id="subsection7-6">
                        <h4>Envoyer un objectif à une action en ligne de commande</h4>
                        <ol>
                            <li>
                                <p>Observez la structure d'une commande pour envoyer un objectif à une action :</p>
                                <div class="code-block" style="background-color: lightgrey;">
<pre class="code-content">
ros2 action send_goal &lt;action_name&gt; &lt;action_type&gt; &lt;values&gt;
</pre>
                                </div>
                            </li>

                            <li>
                                <p>Gardez un oeil sur la fenêtre TurtleSim, et entrez la commande suivante dans votre terminal ([&theta;] = radian):</p>
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code20.2')">Copier</button>
<pre id="code20.2" class="code-content">
ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute "{theta: 1.57}"
</pre>
                                </div>
                                <img src="images/tuto_1/section7/17 send_goal.png" width="450px">
                                <p>Votre tortue, dans la fenêtre TurtleSim, va tourner. Vous obtiendrez cette réponse :</p>
                                <img src="images/tuto_1/section7/18 send_goal_res.png" width="450px">
                                <p>Chaque objectif est associé à un identifiant unique, mentionné dans le message de retour. 
                                De plus, vous pouvez observer le résultat, représenté par un champ nommé "delta", qui indique le déplacement par rapport à la position initiale.
                                </p>
                            </li>

                            <li>
                                <p>Ajoutez le paramètre "<code>--feedback</code>" à la commande ros2 action send_goal, pour voir le feedback d'un objectif. 
                                    Changez la valeur de theta, par exemple <code>&theta;=-1.57</code> et n'oubliez pas d'ajouter le paramètre "<code>--feedback</code>" :
                                </p>    
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code20.3')">Copier</button>
<pre id="code20.3" class="code-content">
ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute "{theta: -1.57}" --feedback
</pre>
                                </div>
                                <img src="images/tuto_1/section7/19 send_goal_feedback.png" width="450px">
                                <p>Votre terminal vous renvoie le message :</p>
                                <div> 
                                    <img src="images/tuto_1/section7/20 send_goal_feedback_res1.png" width="500px">
                                    <img src="images/tuto_1/section7/20 fleche_texte.png" width="500px">
                                    <img src="images/tuto_1/section7/20 send_goal_feedback_res2.png" width="500px">
                                </div>
                                <p>Les actions sont comme des services qui vous permettent d'exécuter des tâches de longue durée. Ces actions fournissent un retour d'information régulier et peuvent être annulées.</p>
                            </li>
                            
                        </ol>
                        
                        <p>Un système robotique utilisera probablement des actions pour la navigation. Un objectif d'action pourrait indiquer à un robot de se rendre à une position. Pendant que le robot navigue vers la position, il peut envoyer des mises à jour en cours de route (c'est-à-dire un retour d'information), puis un message de résultat final une fois qu'il à atteint sa destination.</p>
                        <p>TurtleSim dispose d'un serveur d'action auquel les clients d'action peuvent envoyer des objectifs pour faire bouger les tortues. Dans ce tutoriel, vous avez étudié cette action, <code>/turtle1/rotate_absolute</code>, pour avoir une meilleure idée de ce que sont les actions et comment elles fonctionnent.</p>
                    </section>

                </section>


                <section id="section8">
                    <h3>Comprendre les services avec TurtleSim</h3>

                    <section id="subsection8-1">
                        <h4>Découvrir les services</h4>
                        
                        <ol>
                            <li>
                                <p>Ouvrez un terminal et tapez la commande suivante pour avoir la liste des services actifs en ce moment :</p>
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code22')">Copier</button>
<pre id="code22" class="code-content">
ros2 service list
</pre>
                                </div>
                                <img src="images/tuto_1/section8/service list vide.png" width="225px">
                                <p>Le terminal ne vous renvoie rien. Est-ce normal ? Oui, car aucun noeud n'a encore été lancé et donc aucun service n'est disponible!</p>
                            </li>

                            <li>
                                <p>Lancez TurtleSim en arrière plan dans un second terminal </p>
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code22.0')">Copier</button>
<pre id="code22.0" class="code-content">
ros2 run turtlesim turtlesim_node &
</pre>
                                </div>
                            </li>

                            <li>
                                <p>Tapez à nouveau la commande pour avoir la liste des services actifs :</p>
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code22.1')">Copier</button>
<pre id="code22.1" class="code-content">
ros2 service list
</pre>
                                </div>
                                <img src="images/tuto_1/section8/service list turtlesim.png" width="275px">
                                <p>Comme vous pouvez le voir, tous les services liés au noeud turtlesim et à la <code>turtle1</code> sont visibles, donc actifs.</p>
                            </li>

                            <li>
                                <p>Tapez la commande pour lancer la télécommande dans le second terminal et tapez à nouveau la commande pour avoir la liste des services actifs dans le premier terminal. Vous obtiendrez la liste de services actifs suivants :</p>
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code22.2')">Copier</button>
<pre id="code22.2" class="code-content">
ros2 run turtlesim turtle_teleop_key
</pre>
                                </div>
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code22.3')">Copier</button>
<pre id="code22.3" class="code-content">
ros2 service list
</pre>
                                </div>
                                <img src="images/tuto_1/section8/service list turtlesim teleop.png" width="275px">
                                <p>Vous verrez que les deux nœuds ont six services identiques avec des paramètres dans leurs noms. Presque tous les nœuds de ROS2 ont ces services d'infrastructure à partir desquels les paramètres sont construits.</p>
                            </li>
                        </ol>
                        <p> Dans ce tutoriel, les services de paramètres seront omis de la discussion.</p>
                        <p>Pour l'instant, concentrons-nous sur les services spécifiques à turtlesim, <code>/clear</code>, <code>/kill</code>, <code>/reset</code>, <code>/spawn</code>, <code>/turtle1/set_pen</code>, <code>/turtle1/teleport_absolute</code>, et <code>/turtle1/teleport_relative</code>.</p>
                    </section>

                    <section id="subsection8-2">
                        <h4>Trouver le type d'un service</h4>
                        <p>Les services ont des types qui décrivent comment les données de demande et de réponse d'un service sont structurées. Les types de service sont définis de la même manière que les types de topics, sauf que les types de service ont deux parties : un message pour la demande et un autre pour la réponse.</p>
                    
                        <ol start="0">
                            <li>
                                <p>Les noeuds, TurtleSim et la télécommande, doivent rester actifs pour cette section !</p>
                            </li>
                            <li>
                                <p>Observez la structure d'une commande pour trouver le type d'un service :</p>
                                <div class="code-block" style="background-color: lightgrey;">
<pre id="code23" class="code-content">
ros2 service type &lt;service_name&gt;
</pre>
                                </div>
                            </li>

                            <li>
                                <p>Utilisez cette commande pour le service <code>/clear</code> de TurtleSim (Le service <code>/clear</code> permet d'effacer la trace que la tortue laisse sur la fenêtre de TurtleSim après avoir bougée) :</p>
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code24')">Copier</button>
<pre id="code24" class="code-content">
ros2 service type /clear
</pre>
                                </div>
                                <img src="images/tuto_1/section8/service type clear.png" width="250px">
                                <p>Le terminal vous renvoie :</p>
                                <img src="images/tuto_1/section8/service type clear res.png" width="250px">
                                <p>Le type <code>Empty</code> signifie que l'appel de service n'envoie aucune donnée lorsqu'il émet une requête et ne reçoit aucune donnée lorsqu'il reçoit une réponse.</p>

                            </li>

                            <li>
                                <p>Tapez la commande suivante, pour directement avoir la liste des services actifs et leur type respectif :</p>
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code24.1')">Copier</button>
<pre id="code24.1" class="code-content">
ros2 service list -t
</pre>
                                </div>
                                <img src="images/tuto_1/section8/service list -t.png" width="500px">
                            </li>

                        </ol>
                    </section>

                    <section id="subsection8-3">
                        <h4>Trouver tous les services actifs du même type</h4>
                        <ol>
                            <li>
                                <p>Observez la structure de la commande pour trouver les services d'un certain type :</p>
                                <div class="code-block" style="background-color: lightgrey;">
<pre id="code25" class="code-content">
ros2 service find &lt;type_name&gt;
</pre>
                                </div>
                            </li>

                            <li>
                                <p>Utilisez cette commande pour trouver tous les services actifs du type <code>Empty</code>  :</p>
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code26')">Copier</button>
<pre id="code26" class="code-content">
ros2 service find std_srvs/srv/Empty
</pre>
                                </div>
                                <img src="images/tuto_1/section8/service find cmd.png" width="325px">
                                <p>Le terminal vous renvoie :</p>
                                <img src="images/tuto_1/section8/service find res.png" width="325px">
                            </li>
                        </ol>
                    </section>


                    <section id="subsection8-4">
                        <h4>Trouver la structure du type de service</h4>
                        <ol>
                            <li>
                                <p>Observez la structure de la commande pour trouver la structure d'un type de service :</p>
                                <div class="code-block" style="background-color: lightgrey;">
<pre id="code27" class="code-content">
ros2 interface show &lt;type_name&gt;
</pre>
                                </div>
                            </li>

                            <li>
                                <p>Utilisez cette commande pour trouver la structure du type de service <code>Empty</code> :</p>
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code28')">Copier</button>
<pre id="code28" class="code-content">
ros2 interface show std_srvs/srv/Empty
</pre>
                                </div>
                                <p>Le terminal ne vous renvoie rien et c'est normal car ce type de service est <code>Empty</code>. 
                                    Le type <code>Empty</code> signifie que l'appel de service n'envoie aucune donnée 
                                    lorsqu'il émet une requête et ne reçoit aucune donnée lorsqu'il reçoit une réponse.
                                </p>
                            </li>

                            <li>
                                <p>Trouvez le type du service /spawn. Vous trouverez :</p>
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code28.0')">Copier</button>
<pre id="code28.0" class="code-content">
ros2 service type /spawn
</pre>
                                </div>
                                <img src="images/tuto_1/section8/spawn type.png" width="125px">
                            </li>

                            <li>
                                <p>Trouvez ensuite la structure du type du service <code>/spawn</code> avec la commande :</p>
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code28.1')">Copier</button>
<pre id="code28.1" class="code-content">
ros2 interface show turtlesim/srv/Spawn
</pre>
                                </div>
                                <img src="images/tuto_1/section8/interface show spawn.png" width="500px">
                                <p>Les informations au-dessus de la ligne <code>---</code> nous indiquent les arguments nécessaires pour appeler <code>/spawn</code>. 
                                    <code>x, y</code> et <code>&theta;</code> déterminent la pose 2D de la tortue engendrée, et name est clairement optionnel.
                                </p>
                                <p>Les informations sous la ligne ne sont pas nécessaires dans ce cas, mais elles peuvent vous aider à 
                                    comprendre le type de données de la réponse que vous obtenez lors de l'appel du service <code>/spawn</code>.
                                </p>
                            </li>

                        </ol>
                    </section>

                    <section id="subsection8-5">
                        <h4>Appeler un service</h4>
                        <ol>
                            <li>
                                <p>Observez la structure de la commande pour appeler un service :</p>
                                <div class="code-block" style="background-color: lightgrey;">
<pre id="code29" class="code-content">
ros2 service call &lt;service_name&gt; &lt;service_type&gt; &lt;arguments&gt;
</pre>
                                </div>
                                <p>La partie <code>&lt;arguments&gt;</code> est facultative. Par exemple, vous savez que les services du type <code>Empty</code> n'ont pas d'arguments.</p>
                            </li>

                            <li>
                                <p>Utilisez cette structure de commande pour appeler le service <code>/clear</code>. Le service clear à pour but d'effacer le chemin parcouru par la tortue dans la fenêtre TurtleSim.
                                    Avant d'utiliser cette commande pour effacer le chemin parcouru par la tortue faites bouger la tortue grâce à la télécommande.
                                </p>
                            </li>

                            <li>
                                <p>Tapez la commande suivante pour supprimer le tracé de la tortue :</p>
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code29.1')">Copier</button>
<pre id="code29.1" class="code-content">
ros2 service call /clear std_srvs/srv/Empty
</pre>
                               </div>
                                <img src="images/tuto_1/section8/clear commande call.png" width="350px">
                                <p>Vous pourrez voir le changement suivant dans la fenêtre TurtleSim :</p>
                                <div>
                                    <img src="images/tuto_1/section8/turtlesim av clear.png" width="250px" style="display: inline-block;">
                                    <img src="images/tuto_1/section7/2 fleche.png" width="125px" style="display: inline-block;">
                                    <img src="images/tuto_1/section8/turtlesim ap clear.png" width="250px" style="display: inline-block;">
                                </div>
                            </li>


                        </ol>
                    </section>

                    <section id="subsection8-6">
                        <h4>Faire spawn une nouvelle tortue dans TurtleSim</h4>
                        <ol>
                            <li>
                                <p>Faites spawn une nouvelle tortue en appelant le service <code>/spawn</code> et en définissant des arguments. Les <arguments> d'entrée dans un appel de service à partir de la ligne de commande doivent être en syntaxe <code>YAML</code>.</p>
                                <p>Voici la syntaxe :</p>
                                <div class="code-block">
<button class="copy-button" onclick="copyCode('code30')">Copier</button>
<pre id="code30" class="code-content">
ros2 service call /spawn turtlesim/srv/Spawn "{x: 2, y: 2, theta: 0.2, name: 'turtle_tutoriel'}"
</pre>
                                </div>
                                <img src="images/tuto_1/section8/service call spawn.png" width="640px">
                                <p>Le terminal va vous renvoyer les informations suivantes :</p>
                                <img src="images/tuto_1/section8/service call spawn res.png" width="640px">
                                <p>Ces informations montrent que nous avons appelé le service spawn avec les données <code>x, y</code> et <code>&theta;</code> et qu'en sortie nous avons bien fait spawn une nouvelle tortue nommée comme on le souhaitait.</p>
                            
                            </li>

                            <li>
                                <p>Observez TurtleSim et vous verrez qu'une seconde tortue à apparu au coordonnées que vous avez écrit dans la commande :</p>
                                <img src="images/tuto_1/section8/turtlesim spawn.png" width="250px">
                            </li>
                        </ol>
                        <p>Les nœuds peuvent communiquer en utilisant des services dans ROS 2. Contrairement à un topic - un modèle de communication à sens unique où un nœud publie des informations qui peuvent être consommées par un ou plusieurs 
                            subscribers - un service est un modèle de demande/réponse où un client fait une demande à un nœud fournissant le service et le service traite la demande et génère une réponse.
                        </p>
                        <p>En général, vous ne souhaitez pas utiliser un service pour des appels continus ; des sujets ou même des actions conviendraient mieux.</p>
                        <p>Dans ce tutoriel, vous avez utilisé des outils de ligne de commande pour identifier, introspecter et appeler des services.</p>

                    </section>

                </section>


            </article>
            <!-- Ajoutez d'autres articles pour chaque tutoriel -->
        </section>
    </main>
    
    <script>
        // Fonction pour copier le contenu du bloc de code
        function copyCode(id) {
            const codeBlock = document.getElementById(id);
            const range = document.createRange();
            range.selectNode(codeBlock);
            window.getSelection().removeAllRanges();
            window.getSelection().addRange(range);
            document.execCommand("copy");
            window.getSelection().removeAllRanges();
        }

        // Script pour gérer l'affichage du menu
        var nav = document.querySelector('nav');
        var menuButton = document.getElementById('menu-button');
        var menuDropdown = document.getElementById('menu-dropdown');

        menuButton.addEventListener('click', function() {
            // Toggle la visibilité du menu déroulant
            menuDropdown.style.display = (menuDropdown.style.display === 'block') ? 'none' : 'block';
        });
    </script>
</body>
</html>